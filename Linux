ln filename 创建硬链接（实际上在某个目录新建一条文件名连接到某个inode上，磁盘空间跟inode数目都不会改变）；
ln -s 创建软连接（创建一个独立的文件，而这个文件会让数据的读取指向他连接的那个文件的文件名,而且此文件大小即连接的文件名字符长度）；
type 查看指令是否内建;
Ctrl+u / Ctrl+k 分别是游标处向前以及向后删除指令串；
Ctrl+a / Ctrl+e 分别是让游标移到整个指令串的最前面或最后面；
Ctrl+alt+F1~F6 跳转到tty1~6文字界面 Ctrl+alt+F7图形界面;
env set;
export把自定变量变成环境变量；
locale 语系变量;
read 从键盘读数；
declare/typeset 宣告变量的类型：declare -i sum=12+20;
ulimit 目前权限;
#:从前面删除变量内容 ${path#/*bin}
%:从后面删除变量内容 ${path%/*bin}
${变量/|旧字符串/新字符串} 第一旧就字符串会被新字符串替换
${变量//|旧字符串/新字符串} 全部的旧字符串会被新字符串替换
uname=${uname:-ca} 若uname未设定或为空字符，将uname设为ca;
alias c='clear'; clear的别名;
unalias c; 取消别名;
!vi 是最近指令开头为vi的指令列；
source 也称为点(.)命令，用于重新执行刚修改的初始化文件，使之立即生效，不必注销重新登录；
cmd1 && cmd2 若cmd1执行完且正确，则开始执行cmd2；若错误，则cmd2不执行；cmd1 || cmd2 与之相反;
sort 排序 cat clean | sort;
uniq 想让重复的只显示一次 cat clean | sort | uniq;
wc[-lwm] 查看文档有多少字/多少行/多少字符；
tee 将资料分送去屏幕和文档;
tr 删除文字或替换文字 tr '[a-z]' '[A-Z]'   ;tr -d 's' 删除s;
vim 中替换命令： :[范围]s/from/to/g 将[范围]内的from替换成to;
col/expand 将Tab转为空白键；
join file1 file2 将两个文档“相关部分”相加；
paste file1 file2 将两个文档的同一行贴在一起，用[Tab]隔开;
split [-bl] file 分割文档
vim 模式下输入:sp/:vs实现多窗口编辑,利用[Ctrl]+w 切换;
xargs:生成并引用某个命令行的stdin,xargs可以读入stdin的数据并将stdin数据分割成参数;
LANG=C 表示最简单的C语言环境（ASCII），可用于解决乱码问题;
有时候减号"-"可用于代替stdin和stdout;
ping 是检查网络是否畅通或者网络连接速度；
telnet 是用来探测ip是否开放指定端口；
正则表达式特殊符号：
    [:alnum:] 表示英文大小写字母及数字：0-9 a-z A-Z
    [:alpha:] 表示任何英文大小写字符: a-z A-Z
    [:upper:] 表示英文大写字符：A-Z
    [:lower:] 表示英文小写字符：a-z
    [:digit:] 表示数字：0-9    
[^]反向选择：[^g]oo即不选择oo前面有g的；
行首与行尾字符^ $:'^the'以the开头的 'the$'以the结尾的；
小数点.具有其他意义，要用转义字符\加以解除 '\.$'以.结尾的；
.（小数点）：代表一定有一个任意字符的意思,'g..d'找出'g??d'一共四个字符的字符串；
*（星号）：代表重复前一个字符0到无穷次的意思,0次就是没有，表示空字符（没有字符），'o*'表示有空字符或者一个o以上的字符；'oo*'表示第一个o必须存在，第二个o可有可无；
若要得到g....g得到需求，'g.*g'即可，所以“.*”代表零个或多个字符的意思；
限定连续RE字符范围{}：因为{}在shell里有特殊意义，因此我们要使用转义字符\来让它失去意义：'o\{2\}'代表两个o的字符串；'go\{2,5\}g'表示g后面接2到5个o然后再接一个g的字符串；
sed :一个管道命令，可以分析stdin，还可以对数据进行替换、删除、新增、选取特定行等，sed '3,$d'表示删除3到最后一行；sed -n表示安静模式：只有经过sed特殊处理的行才会被列出来；
RE字符+：o+表示一个以上的o ；'go+d'；
RE字符?：零个或一个前一个RE字符，o?表示空的或者一个o；
RE字符|：用“或”的方法查找，'gd|good'查找gd或good字符串；
RE字符()：找出“组”字符串，'g(la|oo)d'查找glad或者good字符串；
RE字符()+：多个重复组；
egrep支持更严谨的正则表达式；
printf：有格式地输出（不换行）；
awk：主要处理每一行的字段内的数据， awk '{print $1 "\t" $3}' 打印出行第一和第三个字段的数据并用[Tab]分隔；
awk中变量：$0表示一整行数据；NF表示每一行拥有的字段总数；NR表示目前awk处理的是第几行数据；FS表示目前的分隔符，默认是空格键；
diff:按行比较两个文件；cmp:按字节比较两个文件；
patch：更新/还原diff的文件 patch /-R -p0 < passwd.patch（diff制作出来的比较文件通常使用扩展名为.patch）；
pr：打印命令（有时间、标题、页码）；
``操作符跟$()一样:执行里面的命令并以字符串的形式返回；
用户ID：UID；用户组ID：GID；
/etc/passwd 文件结构：每一行是一个账号，每行共有7个字段，用“：”分隔开这7个字段分别是：
    账号名称：密码（都为X）：UID（0为管理员）：GID：用户信息说明列（解释账号的意义）：用户的主文件夹：用户默认的shell
/etc/shadow 文件结构：每一行是账号，每行有9个字段，用“：”分隔开来，这9个字段分别是：
    账号名称：经过加密的密码：最近更改密码的日期（距离19700101的天数）：密码不可被更改的天数：密码需要被更改的天数（强制用户改密码）：密码需要修改期限前的警告天数（ex：7表示密码到期之前7天系统会警告用户）：密码失效期限（密码过期x天后还没修改密码则密码失效）：账号失效日期（账号在规定日期之后无法使用）：保留（待新功能加入）
/ect/group 文件结构：每一行代表一个用户组，一共四个字段，用“：”分隔开，这4个字段分别是：
    用户组名称：用户组密码（一般为X）：GID（用户组ID）：此用户组支持的账号名称
初始用户组：用户一登录即获得；有效用户组：命令groups第一个就是本用户的有效用户组，即新建文件时的文件用户组；
newgrp：有效用户组的切换；
/etc/gshadow 文件结构：四个字段，使用“：”分隔，4个字段分别是：
    用户组名：密码列：用户组管理员的账号：该用户组所属的账号
useradd -m username :创建账号并生成家目录；
passwd -S 可以给一个账号上锁 passwd -u 解锁；
chage：修改密码参数；
usermod:微调账号相关数据；
userdel:删除用户相关数据；
